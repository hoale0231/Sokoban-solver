from queue import Queue, PriorityQueue
from copy import deepcopy
import numpy as np
from time import time, sleep
from sys import argv
from os import system
#from hug import hungarian_algorithm


class Position:
    '''
    Coordinate object
    Support player to move
    '''

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        return hash((self.x, self.y))

    def __add__(self, other):
        return Position(self.x + other.x, self.y + other.y)


def ManhattanDistance(P1: Position, P2: Position):
    return abs(P1.x - P2.x) + abs(P1.y - P2.y)


def PythagoreanDistance(P1: Position, P2: Position):
    return np.sqrt((P1.x - P2.x)**2 + (P1.y - P2.y)**2)


# 4 possible moves = [DOWN, RIGHT, UP, LEFT]
directions = [Position(1, 0), Position(0, 1), Position(-1, 0), Position(0, -1)]

# Convention symbol
WALL = '#'
BOX = 'O'
GOAL = 'X'
BOG = '='  # BOX ON GOAL
PLAYER = 'p'
POG = 'P'  # PLAYER ON GOAL
FLOOR = ' '


class SetState:
    '''
    State are sets of positions of objects on the map
    '''

    def __init__(self):
        self.walls = set()          # Set of walls
        self.goals = set()          # Set of goals
        self.boxes = set()          # Set of boxes
        self.player = Position(0, 0)  # Position of player
        self.route = list()         # Solution route
        self.countBOG = 0           # Count number Box on Goal, use to check goal state
        self.heuristic = 0
        self.deadPos = set()

    # Input map from file
    def initMap(self, filename, deadlock=True):
        map = open(filename).read().split('\n')
        for iRow in range(len(map)):
            map[iRow] = list(map[iRow])
            for iCol in range(len(map[iRow])):
                pos = Position(iRow, iCol)
                char = map[iRow][iCol]
                if char == FLOOR:
                    continue
                elif char == WALL:
                    self.walls.add(pos)
                elif char == BOX:
                    self.boxes.add(pos)
                elif char == GOAL:
                    self.goals.add(pos)
                elif char == PLAYER:
                    self.player = pos
                elif char == BOG:
                    self.boxes.add(pos)
                    self.goals.add(pos)
                    self.countBOG += 1
                elif char == POG:
                    self.goals.add(pos)
                    self.player = pos
        if deadlock:
            self.foundDeadPos(map)

            # help Functions
    def goalPullMetric(self):
        # This function help find all the cost from all the boxes when move to all the goals
        for goal in self.goals:
            result = PriorityQueue()
            for box in self.boxes:
                # check if goal and box is possible
                direction = Position((box.x - goal.x), (box.y-goal.y))
                if direction.x > 0 and (box.x+1) in self.walls:
                    continue
                if direction.x < 0 and (box.x-1) in self.walls:
                    continue
                if direction.y > 0 and (box.y+1) in self.walls:
                    continue
                if direction.y < 0 and (box.y-1) in self.walls:
                    continue
                elif direction.x == 0:
                    result.put((abs(direction.y), goal, box))
                elif direction.y == 0:
                    result.put((abs(direction.x), goal, box))
                else:
                    dis = abs(direction.x) + abs(direction.y)
                    result.put((dis, goal, box))
            return result
            # cach khac?
        # return priority-(u,v)

    def closestGoal(position: Position, boxSet):
        # find closest box for a goal base on pythagorean distance
        distanceVal = set()
        for box in boxSet:
            minBox: Position(0, 0)
            distance = PythagoreanDistance(position, box)
            distanceVal.add(distance)
            if distance == min(distanceVal):
                minBox = box
        return (minBox, distance)

    def greedyAssignment(self):
        # This function assign each box to each goal
        goalboxqueue = PriorityQueue()
        goalboxqueue = self.goalPullMetric()
        matchedBoxes = set()
        matchedGoals = set()
        #match = set()
        totalPath = 0
        while not goalboxqueue.empty():
            (p, g, b) = goalboxqueue.get()
            if not matchedGoals.contains(goalboxqueue) and not matchedBoxes.contains(b):
                matchedGoals.add(g)
                matchedBoxes.add(b)
                #match.add((g, b))
                totalPath += p
        notAssignedBox = set()
        for b in self.boxes:
            if not matchedBoxes.contains(b):
                notAssignedBox.add(b)

        for g in self.goals:
            if not matchedGoals.contains(g):
                b = closestGoal(g, notAssignedBox)
                notAssignedBox.remove(b[0])
                totalPath += b[1]
                #match.add((g, b))
        return totalPath
